diff --git a/constraint/blueprint_logderivlookup.go b/constraint/blueprint_logderivlookup.go
index dc050a65..b26eb055 100644
--- a/constraint/blueprint_logderivlookup.go
+++ b/constraint/blueprint_logderivlookup.go
@@ -12,7 +12,10 @@ import (
 // It is essentially a hint to the solver, but enables storing the table entries only once.
 type BlueprintLookupHint struct {
 	EntriesCalldata []uint32
-	entries         []Element
+	// IsStatic indicates if the lookup table does not grow after first lookup
+	IsStatic       bool
+	staticIsWalked bool
+	entries        []Element
 }
 
 // ensures BlueprintLookupHint implements the BlueprintSolvable interface
@@ -25,7 +28,10 @@ func Time(t time.Time, s string) {
 func (b *BlueprintLookupHint) Solve(s Solver, inst Instruction) error {
 	time1 := time.Now()
 	nbEntries := int(inst.Calldata[1])
-	if len(b.entries) == 0 {
+	if b.IsStatic && len(b.entries) > 0 && len(b.entries) != nbEntries {
+		return fmt.Errorf("lookup blueprint is marked static but table grew")
+	}
+	if (b.IsStatic && len(b.entries) == 0) || (!b.IsStatic) {
 		// read the static entries from the blueprint
 		b.entries = make([]Element, nbEntries)
 		offset, delta := 0, 0
@@ -82,21 +88,27 @@ func (b *BlueprintLookupHint) NbOutputs(inst Instruction) int {
 // This is used by the level builder to build a dependency graph between instructions.
 func (b *BlueprintLookupHint) WireWalker(inst Instruction) func(cb func(wire uint32)) {
 	return func(cb func(wire uint32)) {
-		// depend on the table UP to the number of entries at time of instruction creation.
-		nbEntries := int(inst.Calldata[1])
-
-		// invoke the callback on each wire appearing in the table
 		j := 0
-		for i := 0; i < nbEntries; i++ {
-			// first we have the length of the linear expression
-			n := int(b.EntriesCalldata[j])
-			j++
-			for k := 0; k < n; k++ {
-				t := Term{CID: b.EntriesCalldata[j], VID: b.EntriesCalldata[j+1]}
-				if !t.IsConstant() {
-					cb(t.VID)
+		if !b.IsStatic || (b.IsStatic && !b.staticIsWalked) {
+
+			// depend on the table UP to the number of entries at time of instruction creation.
+			nbEntries := int(inst.Calldata[1])
+
+			// invoke the callback on each wire appearing in the table
+			for i := 0; i < nbEntries; i++ {
+				// first we have the length of the linear expression
+				n := int(b.EntriesCalldata[j])
+				j++
+				for k := 0; k < n; k++ {
+					t := Term{CID: b.EntriesCalldata[j], VID: b.EntriesCalldata[j+1]}
+					if !t.IsConstant() {
+						cb(t.VID)
+					}
+					j += 2
 				}
-				j += 2
+			}
+			if b.IsStatic {
+				b.staticIsWalked = true
 			}
 		}
 
diff --git a/std/lookup/logderivlookup/logderivlookup.go b/std/lookup/logderivlookup/logderivlookup.go
index 82fd146e..1d519bf1 100644
--- a/std/lookup/logderivlookup/logderivlookup.go
+++ b/std/lookup/logderivlookup/logderivlookup.go
@@ -50,7 +50,7 @@ type result struct {
 // New returns a new [*Table]. It additionally defers building the
 // log-derivative argument.
 func New(api frontend.API) *Table {
-	t := &Table{api: api}
+	t := &Table{api: api, blueprint: constraint.BlueprintLookupHint{IsStatic: true}}
 	api.Compiler().Defer(t.commit)
 
 	// each table has a unique blueprint
