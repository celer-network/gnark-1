diff --git a/constraint/blueprint_logderivlookup.go b/constraint/blueprint_logderivlookup.go
index 40efa6ff..f18b4358 100644
--- a/constraint/blueprint_logderivlookup.go
+++ b/constraint/blueprint_logderivlookup.go
@@ -2,6 +2,7 @@ package constraint
 
 import (
 	"fmt"
+	"sync"
 )
 
 // TODO @gbotrel this shouldn't be there, but we need to figure out a clean way to serialize
@@ -15,25 +16,41 @@ type BlueprintLookupHint struct {
 	IsStatic       bool
 	staticIsWalked bool
 	entries        []Element
+
+	onceEntries sync.Once
 }
 
 // ensures BlueprintLookupHint implements the BlueprintSolvable interface
 var _ BlueprintSolvable = (*BlueprintLookupHint)(nil)
 
+func (b *BlueprintLookupHint) getTable(nbEntries int, s Solver) []Element {
+	if !b.IsStatic {
+		return b.readTable(nbEntries, s)
+	} else {
+		b.onceEntries.Do(func() {
+			b.entries = b.readTable(nbEntries, s)
+		})
+		return b.entries
+	}
+}
+
+func (b *BlueprintLookupHint) readTable(nbEntries int, s Solver) []Element {
+	// read the static entries from the blueprint
+	entries := make([]Element, nbEntries)
+	offset, delta := 0, 0
+	for i := 0; i < nbEntries; i++ {
+		entries[i], delta = s.Read(b.EntriesCalldata[offset:])
+		offset += delta
+	}
+	return entries
+}
+
 func (b *BlueprintLookupHint) Solve(s Solver, inst Instruction) error {
 	nbEntries := int(inst.Calldata[1])
 	if b.IsStatic && len(b.entries) > 0 && len(b.entries) != nbEntries {
 		return fmt.Errorf("lookup blueprint is marked static but table grew")
 	}
-	if (b.IsStatic && len(b.entries) == 0) || (!b.IsStatic) {
-		// read the static entries from the blueprint
-		b.entries = make([]Element, nbEntries)
-		offset, delta := 0, 0
-		for i := 0; i < nbEntries; i++ {
-			b.entries[i], delta = s.Read(b.EntriesCalldata[offset:])
-			offset += delta
-		}
-	}
+	entries := b.getTable(nbEntries, s)
 	nbInputs := int(inst.Calldata[2])
 
 	// read the inputs from the instruction
@@ -50,11 +67,11 @@ func (b *BlueprintLookupHint) Solve(s Solver, inst Instruction) error {
 
 	for i := 0; i < nbOutputs; i++ {
 		idx, isUint64 := s.Uint64(inputs[i])
-		if !isUint64 || idx >= uint64(len(b.entries)) {
+		if !isUint64 || idx >= uint64(len(entries)) {
 			return fmt.Errorf("lookup query too large")
 		}
 		// we set the output wire to the value of the entry
-		s.SetValue(uint32(i+int(inst.WireOffset)), b.entries[idx])
+		s.SetValue(uint32(i+int(inst.WireOffset)), entries[idx])
 	}
 	return nil
 }
